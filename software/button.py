# Debounced Button

import time  # using functions not compatible with Cpython

class Button:
    """ Button/switch handling class.

    The class assumes the Pin polarity is 0: button pressed, 1: button not pressed.
    
    The button state is debounced according to the debounce delay `delay`.
    
    The method `value()` returns how many times the button was pressed since the last time that method was called.
    
    The class set up an IRQ on the specified pin, which is attached to the `process_irq()` method. This method can be optinally wrapped by the function provided in `irq_wrapper`.

    Parameters:

      sw (machine.Pin): Pin object corresponding to the pin that is connected to the switch.

      delay (int): debouncing delay, in ms

      irq_wrapper (func): Function that wraps the irq handler, typically to mask interrupts under some external conditions.

    Principle of operation:  When an IRQ occurs, we store the value of the pin
    in ``self.last_state``. If the value has changed, we store the time of the
    transition and any interrupt hapenning before `delay` are then ignored to
    ignore the flurry of transitions caused by the switch bouncing. If the
    value of the pin changed from 1 to 0, we increment ``self._down``.
    """
    def __init__(self, sw, delay=50, irq_wrapper=None):
        self.sw = sw
        self.delay = delay
        self.last_time = 0
        self._down = 0
        self._up = 0
        self.last_state = 1
        if irq_wrapper:
            self.sw.irq(irq_wrapper(self.process_irq))
        else:
            self.sw.irq(self.process_irq)

    def process_irq(self, pin):
        """ Process the interrupt request generated by the button state change

        Parameters:

            pin (machine.Pin): Pin object that caused the interrupt

        """
        v = pin.value() # get button state ASAP
        t = time.ticks_ms()
        # if verbose:
        #     print(f'Button {pin}= {self.last_state}->{v} dt0={time.ticks_diff(t, self.last_time)}')
        # Ignore pin state changes if we are in the bounce rejecting window
        if time.ticks_diff(t, self.last_time) > self.delay:
            # if we detect a pin value change compared to the latest known state, restart the bounce reject window, check if it is a button-down event, and store the new button state. 
            if v != self.last_state:
                # Restart the bounce reject window
                self.last_time = t  
                # Check if this is a  button down event (1 to 0). If so, register the event.
                if not v and self.last_state:
                    self._down += 1
                elif v and not self.last_state:
                    self._up += 1
                    # if verbose:
                    #     print(f'                     Button {pin} value={self._down}')
                # store the new state
                self.last_state = v


    def value(self):
        """ Same as down()
        """
        ret_value = self._down
        self._down = self._up = 0
        return ret_value

    def is_down(self):
        return not self.sw.value()

    def down(self):
        ret_value = self._down
        self._down = self._up = 0
        return ret_value


    def up(self):
        ret_value = self._up
        self._down = self._up = 0
        return ret_value

    def clear(self):
        self._down = self._up = 0
